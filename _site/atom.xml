<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title></title>
 <link href="http://pepegramming.site/atom.xml" rel="self"/>
 <link href="http://pepegramming.site/"/>
 <updated>2024-08-30T21:38:51+03:00</updated>
 <id>http://pepegramming.site</id>
 <author>
   <name>Anton Davydov</name>
   <email></email>
 </author>

 
 <entry>
   <title>Как уменьшить размер события в асинхронных коммуникациях</title>
   <link href="http://pepegramming.site/questions/make-events-small/"/>
   <updated>2024-08-30T00:00:00+03:00</updated>
   <id>http://pepegramming.site/questions/make-events-small</id>
   <content type="html">&lt;h2 id=&quot;вопрос&quot;&gt;Вопрос&lt;/h2&gt;

&lt;div class=&quot;question-text&quot;&gt;
  &lt;blockquote&gt;
    &lt;p&gt;Привет!&lt;/p&gt;

    &lt;p&gt;Вопрос: что делать если требуется чтоб в message bus были максимально короткие сообщения?&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/div&gt;

&lt;p&gt;Так как вопрос абстрактный, то можно выделить две ситуации, в которой необходимо «короткое» событие:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Хочу короткие сообщения, потому что так «принято»;&lt;/li&gt;
  &lt;li&gt;Есть проблема с брокером/трафиком/деньгами, и нужно решение для уменьшения размера payload в событии. При этом, концептуально событие корректно;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Давайте рассмотрим каждый из вариантов.&lt;/p&gt;

&lt;details class=&quot;collapse_block&quot;&gt;
  &lt;summary class=&quot;collapse_block__title&quot;&gt;Заумь: душный кусок, который задает понятийный аппарат и который можно пропустить&lt;/summary&gt;

  &lt;div class=&quot;collapse_block__content&quot;&gt;

    &lt;p&gt;К сожалению, без духоты, в виде зауми, могут появиться додумки или недопонимания, поэтому лучше договориться на берегу.&lt;/p&gt;

    &lt;p&gt;Дальше по тексту будут использоваться три термина связанных с событиями, поэтому давайте договоримся на берегу, что подразумевается под каждым из терминов.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Событие (event)&lt;/strong&gt; – факт того, что произошло в прошлом. Всегда именуется глаголом в прошедшем времени, причем безвозвратным. Например, если что-то покупается в интернет магазине, то событие будет “заказ оформлен”;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Команда (command)&lt;/strong&gt; – действие которое кто-то должен выполнить, обозначаются глаголом в настоящем времени. Если вернуться к примеру с заказом, то “оформить заказ”, как действие, можно отправить асинхронно. Для команд, текст ниже также валиден;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Payload&lt;/strong&gt; – кроме названия того, что произошло, нужен и контекст, который добавляет конкретной информации, что именно произошло. Т.е. если мы “оформили заказ”, то желательно знать что это за заказ (хотя бы его id), кто это сделал, когда, какие товары были в заказе, какая стоимость (общая и каждого товара) и так далее. Все это является контекстом события, который находится в payload-е события. Для команды аналогично;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Событие в общем виде можно представить так

event ItemAddedToCart { # ItemAddedToCart - название события
  id: int, # тут описываем payload
  # ... 
}

# Команда выглядит так

command AddItemToCart { # AddItemToCart - название команды, которую кто-то выполнит
  id: int, # тут описываем payload
  # ... 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Бизнес событие&lt;/strong&gt; – событие которое говорит о том, что какой-то бизнес процесс завершился с каким-то результатом. Если знакомы с EventStorming – оранжевый стикер с событием будет аналогом. Если знакомы с DDD – domain event близок по смыслу;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Продьюсинг и консьюминг (producing/consuming)&lt;/strong&gt; – терминология из кафки (и аналогов). Producer отправляет события, consumer потребляет. В кролилке любят использовать publisher/subscriber терминологию, что одно и тоже. Но в ответе будет использоваться терминология из кафки;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Брокер (message broker)&lt;/strong&gt; – очередь/распределенный лог/стриминг платформа используемый для передачи событий из A в B;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;Вот об уменьшении payload-а события и поговорим в контексте вопроса.&lt;/p&gt;

  &lt;/div&gt;
&lt;/details&gt;

&lt;h2 id=&quot;хочу-короткие-сообщения-потому-что-так-принято&quot;&gt;Хочу короткие сообщения, потому что так «принято»&lt;/h2&gt;

&lt;p&gt;Первое, с чего надо начинать, когда дело касается размера payload в событии – определиться с двумя концепциями: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state (fact) vs delta (action) events&lt;/code&gt; и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;event granularity&lt;/code&gt;. Чаще эти два понятия даются отдельно и не связывают между собой. Но сегодня особый случай – будем рассматривать концепции в связке.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-30-make-events-small/fine-coarse-state-delta-matrix.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;«Матрица» связи state/delta и event granularity концепций, которую будем использовать дальше&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h3 id=&quot;state-fact-vs-delta-action-events&quot;&gt;State (fact) vs delta (action) events&lt;/h3&gt;

&lt;p&gt;Существует два подхода к хранению состояния в событиях:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;State (or fact) event – хранит полное состояние агрегата/бизнес события на момент продьюсинга;&lt;/li&gt;
  &lt;li&gt;Delta (or action) event – хранит только изменения которые произошли в событие на момент продьюсинга;&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-30-make-events-small/state-vs-delta-events.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Пример двух одинаковых событий: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ItemAddedToOrder&lt;/code&gt;. В delta событии показывается только то, что изменилось, в state – указывается весь «снапшот» &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;order&lt;/code&gt; агрегата&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Дополнение:&lt;/strong&gt; считается, что событие не может быть наполовину state и на половину delta. Но в реальности встречал ситуации, когда передавался полный агрегат + изменения только вложенных данных. Поэтому считаю значения не бинарными в этом ответе.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;плюсы-и-минусы-state-events&quot;&gt;Плюсы и минусы state events&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Плюсы&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Так как не надо считать состояние из кучи delta событий (которые могут быть разбросаны по разным очередям/топикам), то можно пропустить прошлые события, чтобы получить текущий слепок состояния;&lt;/li&gt;
  &lt;li&gt;Если меняется схема событий – проще исправить одно state событие, чем пачку delta;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Минусы&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Cобытие может оказаться слишком большим (наш случай);&lt;/li&gt;
  &lt;li&gt;Не понятно что изменилось, если ордеринг событий нарушится. Из-за этого можно будет обновить новые данные на старые и получить не консистентный стейт;&lt;/li&gt;
  &lt;li&gt;Если изменения частые, может быть действительно слишком много лишних данных об одном и том же;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;плюсы-и-минусы-delta-events&quot;&gt;Плюсы и минусы delta events&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Плюсы&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;События будут меньше по размеру, в отличии от state событий, так как там не будет ничего лишнего;&lt;/li&gt;
  &lt;li&gt;Если изменения частые – можно выиграть в трафике и количестве данных, которые храняться на стороне консьюмера;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Минусы&lt;/strong&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Исправление проблем со схемой событий может стать еще большей проблемой. Частный случай – решение проблемы GDPR и другие “удаления” данных могут быть проблемными;&lt;/li&gt;
  &lt;li&gt;Придется следить за event ordering;&lt;/li&gt;
  &lt;li&gt;Если для обработки события нужен полный агрегат (все данные агрегата) – придется хранить локальное состояние агрегата;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;event-granularity&quot;&gt;Event granularity&lt;/h3&gt;

&lt;p&gt;Вторая концепция раскрывает идею state/delta событий, но в плоскости полезности и полноты события. Для этого вводятся понятия coarse и  fine событий.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-30-make-events-small/fine-vs-coarse-events.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Пример двух одинаковых событий с добавлением товара в корзину. В coarse событии слишком много не понятно зачем относящихся данных, fine событие слишком специфичное и мелкое&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h4 id=&quot;coarse-событие&quot;&gt;Coarse событие&lt;/h4&gt;

&lt;p&gt;Такие события большие и общие (т.е. обо всем сразу), содержат дженерик нейминг и кучу данных не обязательных (и местами не нужных) для работы консьюмера.&lt;/p&gt;

&lt;p&gt;Иногда встречаются ситуации, когда событие так себе называется и контекст того, что произошло, можно понять только через чтение данных. Из-за этого бизнес логика просачивается на сторону консьюмера.&lt;/p&gt;

&lt;h4 id=&quot;fine-событие&quot;&gt;Fine событие&lt;/h4&gt;

&lt;p&gt;Такие события слишком мелкие и специфичные. Чаще нормально называются, но слишком в них мало информации для работы бизнес логики&lt;/p&gt;

&lt;p&gt;Считается, что такое событие не юзабельно без других событий, следовательно приходится их комбинировать и это может привести к проблемам, что потенциально может привести к проблемам с event ordering.&lt;/p&gt;

&lt;h3 id=&quot;собираем-концепции-вместе&quot;&gt;Собираем концепции вместе&lt;/h3&gt;

&lt;p&gt;Если соединить две концепции, то появляется пространство выбора, в котором можно определить как оптимальный размер события, так то, на сколько общим (generic) событие будет в системе.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-30-make-events-small/fine-coarse-state-delta-matrix-event-size.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Примерное описание того, какой размер события ожидать в каждом из мест «матрицы». Цветом показал ожидаемый размер события. Fine delta событие будет самым мелким, поэтому стикер зеленый&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;В таком ключе, вся работа над размером событий сводится к тому, что бы сначала сначала определяется какой вид события нужен: state или delta. После чего определяем проблему гранулярности события и решаем найденную проблему.&lt;/p&gt;

&lt;p&gt;Благодаря этому можно выбирать размер события. Что приводит к тому, что каждое событие будет оптимально по размеру и контексту под заданные требования и ограничения. Благодаря чему можно отказаться от «моды»/советов на delta события без данных, просто потому что в компании Х используется такой подход по дефолту.&lt;/p&gt;

&lt;p&gt;Но у такого подхода присутствует и минус: придется думать над каждым событием, что может привести к разногласиям в команде, либо же к проблемам, если разработчики не скиловые. Можно решить что хватит delta/fine события, а потом окажется, что не попали в требования. Из-за чего придется заниматься дорогой и сложной эволюцией схемы события.&lt;/p&gt;

&lt;h2 id=&quot;событие-корректное-по-размеру-но-слишком-большое-для-системы&quot;&gt;Событие корректное по размеру, но слишком большое для системы&lt;/h2&gt;

&lt;p&gt;К сожалению, использование концепции &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state (fact) vs delta (action) events&lt;/code&gt; и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;event granularity&lt;/code&gt; не спасает в 100% случаев от проблем с размером события. Возможна ситуация, когда необходим state event, который при этом должен быть coarse. Т.е. вообще никак не выбрать ничего другого. А размер события должен быть максимально небольшим ибо специфика брокера/нет денег на инфру/etc.&lt;/p&gt;

&lt;p&gt;Чтобы решить эту проблему перечислю точечные подходы, которые разбиваются на две группы:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;уменьшаем payload сообщения с помощью паттернов *;&lt;/li&gt;
  &lt;li&gt;увеличиваем допустимые размеры сообщения в брокере;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;* Для некоторых вариантов придется подумать о консистентности данных в payload, ибо не все варианты работают со strong consistency.&lt;/p&gt;

&lt;h3 id=&quot;уменьшение-размера-сообщений-без-потери-гранулярности&quot;&gt;Уменьшение размера сообщений без потери гранулярности&lt;/h3&gt;

&lt;h4 id=&quot;убрать-лишние-данные-в-ручную&quot;&gt;Убрать лишние данные в ручную&lt;/h4&gt;

&lt;p&gt;Очевидное решение, пересекающее с концепциями из первой части ответа: берем событие, смотрим какие данные нужны в каждом консьюмере события, после чего, ковыряясь в payload, выкидываем лишние данные. Т.е. делаем событие больше fine чем coarse:&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-30-make-events-small/less-coarse-event.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Может оказаться, что событие надо сделать не таким coarse, следовательно, по «матрице» оно опустится чуть ниже&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h4 id=&quot;event-notification&quot;&gt;Event notification&lt;/h4&gt;

&lt;p&gt;Если получали смс «осторожно, будет шторм», а потом шли смотреть где шторм, когда и кого зацепит – значит знакомы с паттерном.&lt;/p&gt;

&lt;p&gt;По сути, паттерн частный случай delta события. Идея такая: отправляем событие, что что-то произошло, но контекст просим получить с помощью синхронного вызова. Подход нужен в двух случаях: когда необходимо передать большое количество данных, либо когда нужно максимально консистеные данные получить в событии. В контексте ответа на вопрос интересен первый случай.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-30-make-events-small/event-notification-example.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Пример реализации event notification паттерна. Сначала отправляется событие с ссылкой на ресурс. После этого, консьюмер, делает запрос за данными и получает контекст&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Подобным образом можно передавать аттачменты в событиях: кидаем файл в s3, получаем ссылку, а после ссылку передаем в событии, благодаря чему можно не грузить гигабайты видео и картинок в брокер.&lt;/p&gt;

&lt;p&gt;Из минусов подхода – появляется дополнительный каплинг за счет синхронной связи, что влияет на reliability, availability и другие характеристики.&lt;/p&gt;

&lt;h4 id=&quot;воспользоваться-бинарной-сериализацией&quot;&gt;Воспользоваться бинарной сериализацией&lt;/h4&gt;

&lt;p&gt;Если удалять из схемы payload нечего, а использовать синхронный вызов не позволяют характеристики, можно ужать само сообщение. Для этого берем бинарный серелизатор и упаковываем payload. По итогу получаем ужатую строку, которая меньше на 25-50% чем оригинальный payload (больше данных - больше ужимает).&lt;/p&gt;

&lt;p&gt;Из минусов - без десериализации человек такую бинарную строку быстро не прочитает, в отличии от human-readable форматов (json, xml, etc). Еще из минусов – придется думать как консьюмер поймет какую схему использовать для десерелизации (либо 1 событие на топик/очередь, либо название события в headers кафки прокидывать).&lt;/p&gt;

&lt;p&gt;Популярные серелизаторы: &lt;a href=&quot;https://github.com/protocolbuffers/protobuf&quot;&gt;protobuf&lt;/a&gt; (в grpc используется), &lt;a href=&quot;https://github.com/apache/avro&quot;&gt;avro&lt;/a&gt;, &lt;a href=&quot;https://github.com/apache/thrift&quot;&gt;apache thrift&lt;/a&gt;. В некоторых языках реализованы решения из коробки, &lt;a href=&quot;https://www.erlang.org/doc/apps/erts/erl_ext_dist.html&quot;&gt;например в erlang&lt;/a&gt; (использовать только тем, кто контрибьютил в пакет).&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-30-make-events-small/avro-vs-protobuf-size-comparison.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Разработчик решил проверить, что будет если &lt;a href=&quot;https://cristian-matei-toader.medium.com/compressing-a-year-of-reddit-with-apache-avro-and-google-protobuf-c9e40cf90444&quot;&gt;ужать датасет kaggle 2015 года от reddit&lt;/a&gt;. Скриншот выше – итоговый результат, который мало говорит о том, что лучше, но показывающий как можно уменьшить размер события&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h4 id=&quot;message-chunking&quot;&gt;Message chunking&lt;/h4&gt;

&lt;p&gt;Если описанные выше варианты не подошли, можно воспользоваться идеей передачи больших данных в синхронных вызовах: поделить сообщение на чанки меньшего размера и вместо одного жирного события получить N мелких.&lt;/p&gt;

&lt;p&gt;Из минусов – проблемы с strong consistency для payload события, плюс проблемы упаковки чанков в событие на стороне консьюмера.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-30-make-events-small/message-chunking-example.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Пример из вики apache pulsar. Идея в том, что событие разбивается на чанки (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;M1-C1&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;M1-C2&lt;/code&gt;), после чего консьюмер собирает из чанков исходное событие&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h4 id=&quot;передавать-часть-данных-в-других-событиях&quot;&gt;Передавать часть данных в других событиях&lt;/h4&gt;

&lt;p&gt;На первый взгляд решение может показаться идентичным message chunking, но концепция чуть отличается.&lt;/p&gt;

&lt;p&gt;Идея в том, что можно разделить связи между элементами в плоскости &lt;a href=&quot;https://en.wikipedia.org/wiki/Form,_fit_and_function&quot;&gt;system function и system form&lt;/a&gt;. Благодаря чему появится два вида связности: по данным (это form) и на уровне поведения (function). Это приводит к идее, что если присутствует событие, которое говорит о поведении, для обработки которого нужны данные, эти данные можно передать через system form связь.&lt;/p&gt;

&lt;p&gt;Для определения system form можно воспользоваться &lt;a href=&quot;https://pepegramming.site/questions/data-model/&quot;&gt;концептуальной data model&lt;/a&gt;, а для определения system function – любой моделью, описывающей поведение, например EventStorming.&lt;/p&gt;

&lt;h3 id=&quot;тюнинг-брокера&quot;&gt;Тюнинг брокера&lt;/h3&gt;

&lt;p&gt;Сразу скажу – не эксперт в инфраструктуре, поэтому накину идей. Лучше идите к DevOps инженерам или админам (сам так делаю).&lt;/p&gt;

&lt;p&gt;Как могу судить, тут два подхода: либо крутить конфиг брокера, либо использовать специфичные инструменты реализованные в брокере:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Если возникла проблема, что событие не влезает в брокер, то можно накрутить конфиг &lt;a href=&quot;https://stackoverflow.com/questions/21020347/how-can-i-send-large-messages-with-kafka-over-15mb&quot;&gt;кафки&lt;/a&gt; или &lt;a href=&quot;https://www.cloudamqp.com/blog/what-is-the-message-size-limit-in-rabbitmq.html&quot;&gt;кролика, но тут лимит в 128 мб&lt;/a&gt;. Для других брокеров думаю можно найти аналогичные настройки;&lt;/li&gt;
  &lt;li&gt;Если используете кафку, советую посмотреть в сторону &lt;a href=&quot;https://www.confluent.io/blog/apache-kafka-message-compression/&quot;&gt;message compression&lt;/a&gt;. Подход сработает для xml, json и прочего, что легко компрессируется и содержит дубли. По сути, аналог серелизации из списка выше;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Знаете еще варианты? Пишите в комментариях к тг посту, соберем список, а я дополню эту часть ответа.&lt;/p&gt;

&lt;h2 id=&quot;выводы&quot;&gt;Выводы&lt;/h2&gt;

&lt;p&gt;Уменьшение объема payload события не тривиальная задача, которую в первую очередь лучше решать через &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state (fact) vs delta (action) events&lt;/code&gt; и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;event granularity&lt;/code&gt; концепции. Но даже так, возникают ситуации, когда приходится точечно исправлять ситуацию, с чем помогают как паттерны, так и прямой конфиг брокера (если возможен).&lt;/p&gt;

&lt;p&gt;А чтобы собрать ответ в кучу, сделал decision flow диаграмму, которую сам использую, когда проектирую события, надеюсь поможет.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-30-make-events-small/event-size-decision-flow.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Флоу выбора решения, который использую, если дело касается размера payload события&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Хотя, в идеале, лучше жить в мире, в котором денег много, а инструменты не ограничивают в размере событий.&lt;/p&gt;

&lt;h2 id=&quot;ссылки&quot;&gt;Ссылки&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;[en]  &lt;a href=&quot;https://barryosull.com/blog/event-granularity-modelling-events-in-event-driven-applications/&quot;&gt;Статья, которая рассказывает о концепции event granularity с fine и coarse событиями&lt;/a&gt;. При этом, автор объясняет почему появляются те или иные виды событий события;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;[en]  &lt;a href=&quot;https://developer.confluent.io/courses/event-design/fact-vs-delta-events/&quot;&gt;Статья о state и delta событиях&lt;/a&gt;. Текста много, но и объясняется куча нюансов;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;[en]  &lt;a href=&quot;https://www.funnel-labs.io/2022/08/26/data-serialization-apache-avro-vs-google-protobuf/&quot;&gt;Сравнение avro и protobuf серелизаторов&lt;/a&gt; между собой;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://dataintensive.net&quot;&gt;4 глава DDIA&lt;/a&gt; посвящена сериализации данных. Если не читали – рекомендую;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;[en]  &lt;a href=&quot;https://cristian-matei-toader.medium.com/compressing-a-year-of-reddit-with-apache-avro-and-google-protobuf-c9e40cf90444&quot;&gt;Статья, в которой автор вдохновился DDIA и решил ужать датасет реддита&lt;/a&gt;, чтобы понять какой сериализатор лучше. Результат проверки найдете картинкой в ответе выше;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;[en]  Советы по работе с большими сообщениями, которые описаны в вики apache pulsar. &lt;a href=&quot;https://github.com/apache/pulsar/wiki/PIP-37:-Large-message-size-handling-in-Pulsar#option-2-producer-publish-marker-message-after-publishing-all-chunked-messages&quot;&gt;Message chunking – один из вариантов решения&lt;/a&gt;;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;[ru] Подробнее о разделении коммуникаций на поведение и данные (form, function) можно &lt;a href=&quot;https://f213.notion.site/dfa7f424ed8440d99a21c328cc8c5c65&quot;&gt;почитать в открытом уроке курса&lt;/a&gt;, по анализу систем, который сделал;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;[en] Автор дает &lt;a href=&quot;https://jcdubs.medium.com/aws-large-payload-pattern-e3e4c57d402d&quot;&gt;советы тем, кто использует aws инфраструктуру и хочет работать с большими событиями&lt;/a&gt;. Примеры кода на js;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Как слежу за большими проектами</title>
   <link href="http://pepegramming.site/questions/graph-as-a-project-managment-tool/"/>
   <updated>2024-08-16T00:00:00+03:00</updated>
   <id>http://pepegramming.site/questions/graph-as-a-project-managment-tool</id>
   <content type="html">&lt;h2 id=&quot;вопрос&quot;&gt;Вопрос&lt;/h2&gt;

&lt;div class=&quot;question-text&quot;&gt;
  &lt;blockquote&gt;
    &lt;p&gt;Привет!&lt;/p&gt;

    &lt;p&gt;Вопрос: как планируешь и следишь за долгими проектами? Особенно интересно что используешь для долгих проектов, которые дляться от года и больше, потому что в какой-то момент перестаю видеть «лес» за тасками в трекере.&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/div&gt;

&lt;p&gt;Давайте разбираться. Важно: я не менеджер, людьми не управляю. Отчеты по работе и планированием спринтов тоже не занимаюсь. Поэтому буду говорить с позиции solution architect и касаемо только рабочих проектов.&lt;/p&gt;

&lt;p&gt;При этом, описываться будет личный опыт, из-за чего допускаю, что ответ подойдет далеко не всем: кто-то следит за проектами в «джире», кто-то получает результат от менеджеров. Поэтому буду рад если описанный подход либо вдохновит, либо поможет в текущей ситуации.&lt;/p&gt;

&lt;p&gt;И еще одно уточнение: в тексте буду использовать «джира» как обобщенное слово для любого PM инструмента. О jira тоже поговорим.&lt;/p&gt;

&lt;h2 id=&quot;контекст-в-котором-приходится-планировать-работу&quot;&gt;Контекст в котором приходится планировать работу&lt;/h2&gt;

&lt;p&gt;Для начала стоит описать контекст в котором нахожусь как solution architect. С этим поможет первая глава &lt;a href=&quot;https://www.oreilly.com/library/view/solution-architecture-foundations/9781780175676/&quot;&gt;Solution Architecture Foundations&lt;/a&gt;, в которой описываются активности роли. Из списка хочется выделить три:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;управление доставкой решения, в которое входит роадмап из текущей ситуации в будущее, где проблема решена;&lt;/li&gt;
  &lt;li&gt;Организация процесса, в который входит коммуникации между стейкхолдерами на разные темы;&lt;/li&gt;
  &lt;li&gt;Взаимодействие со стейкхолдерами проекта, в которое входят как получение информации, которая потом шарится будет;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Как можете понять, я не занимаюсь менеджментом разработчиков и людей (да и не хочу). Поэтому мне не надо считать сторипоинты, гадать сколько эпиков влезет в спринт и продавать &lt;a href=&quot;https://community.atlassian.com/t5/App-Central/3-tools-to-analyze-Cycle-and-Lead-Time-in-the-Jira/ba-p/1403775&quot;&gt;красивые графики по распределению времени работы&lt;/a&gt;. С другой стороны, во время работы необходимо понимать в каком состоянии находится проект, где затыки, объяснение почему что-то долго происходит и другие вещи, связанные с обсервабилити работы. Что бы было нагляднее, покажу на &lt;a href=&quot;https://en.wikipedia.org/wiki/V-model&quot;&gt;v-model&lt;/a&gt;, в какие моменты приходится наблюдать за тем, что делают другие.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/v-model-and-personal-managment.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Дизайн, имплементация и верификация – три фазы, на которых приходится «держать руку на пульсе»&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Т.е. задача сводится к трем вещам:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;На этапе дизайна помочь спланировать работу и провалидировать, что план понятен и устраивает каждого стейкхолдера. А также проверить, что план влезает в ресурсы и цена решения будет приемлемой;&lt;/li&gt;
  &lt;li&gt;На этапе имплементации знать в каком состоянии находится проект и какие проблемы появляются. Плюс знать когда приступать к работе над другими частями системы (если требуется);&lt;/li&gt;
  &lt;li&gt;На этапе верификации нужно проверить, что система будет провалидирована перед тем, как оказаться в проде;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;По итогу, нужен инструмент который решает следующие проблемы:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Помогает в быстром прототипировании этапов работы и валидации этих этапов с каждым из стейкхолдеров проекта (бизнесом и разработчиками);&lt;/li&gt;
  &lt;li&gt;Инструмент должен работать для разных команд/отделов. Т.е. встречаются проекты, которые затрагивают от двух команд из разных отделов и необходимо синхронизировать последовательность работ между ними;&lt;/li&gt;
  &lt;li&gt;Важно как можно быстрее понять в каком состоянии проект на выбранный момент времени, или как быстро происходит требуемая эволюция. Т.е. в идеале, нужен инструмент, который позволит работать с «концептуальной» моделью работы над проектом (о концептуальной/логической/технической модели можно прочитать &lt;a href=&quot;https://pepegramming.site/questions/data-model/&quot;&gt;в прошлом ответе&lt;/a&gt;);&lt;/li&gt;
  &lt;li&gt;Так как ко мне могут прийти и спросить либо почему так долго выполняются работы, либо просто спросить что происходит – нужен артефакт для стейкхолдеров, который покажу и от меня отстанут;&lt;/li&gt;
  &lt;li&gt;Решение должно быть кросс-платформенное. Связано со спецификой работы, так как за последние четыре года использовались следующие инструменты: бейскамп, джира, редмайн, асана, миро (не спрашивайте), пяток штук для рисования ганта, гитхаб доски, трелло и другие. Если инструмент окажется вендорлоком - я не смогу решение протащить в другой проект;&lt;/li&gt;
  &lt;li&gt;Инструмент должен хранить задачи, которые вроде как надо бы сделать, но пока не понятно как, когда и нужно ли это вообще;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Дополнительные пожелания:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Чем меньше элементов и информации, тем лучше. Т.е. сроки, таймлайны и прочее хотелось бы убрать. Этим пусть занимаются тимлиды с командами;&lt;/li&gt;
  &lt;li&gt;Хочется иметь инструмент для собственной рефлексии:
  - Понимать на сколько изначальные планы отличаются от того, что получилось в конце эволюции;
  - Нужна ретроспектива, что бы быстро понимать как долго делаются задачи и замечать проблемы. Плюс понимать как сильно ошибался в начале и в конце работы (видеть как много добавилось нового во время работы)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;почему-project-management-tools-не-сработают&quot;&gt;Почему project management tools не сработают&lt;/h3&gt;

&lt;p&gt;Может показаться, что под требования подойдет любой продукт для project planning/management. На деле, подобные инструменты только усложняют работу и связано это с тем, что списки задач не работают для высокоуровневого планирования.&lt;/p&gt;

&lt;p&gt;Проблема тут в том, что задачи редко когда связаны последовательно между собой. В качестве примера можно привести «базовую» задачу по выносу кода из монолита в новый сервис. Если сильно не упарываться, то список шагов можно представить как такую последовательность: &lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Сделать новый сервис с копией логики существующего модуля монолита

1. поднять новую базу данных
2. поднять болванку с пустым сервисом
3. настроить деплоймент
4. настроить observability (метрики, логи, etc)
5. настроить репликацию данных из монолита в новую базу данных
6. проверить, что данные валидны и соответствуют реальности
7. реализовать бизнес логику в сервисе
8. проверить, что бизнес логика работает корректно с данными
9. перевести трафик с монолита на новый сервис
10. проверить что итоговое решение работает корректно
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Вроде кажется, что работа последовательна и тут нечего параллелить, достаточно сделать проекты под каждый шаг и фигачить пару месяцев.  Но если представить шаги как «граф», то оказывается, что есть как минимум три трека, в которых задачи могут быть распараллелены, а сам процесс не так линеен, как кажется на первый взгляд&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/example-service-extraction-final.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Тот же список по выносу логики из монолита, который теперь выглядит как граф, а не последовательные работы&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;В тех инстурментах, что я знаю или использовал (jira, asana, basecamp, clubhouse, redmine, любая kanban доска, etc) нельзя быстро понять связь между задачами. Т.е. настроить и посмотреть связанные задачи можно, но в голове придется рисовать картинку выше, что отнимает время и силы. А в больших проектах, где задействуются команды из разных отделов, подобные действия могут превратиться в дни анализа. Хотя не исключаю, что я не преисполнился мудростью и плохо знаю инструменты, так как не менеджер.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/jira-go-brrr.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Подозреваю, что прошаренные менеджеры как-то так воспринимают этот текст&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h2 id=&quot;мой-подход&quot;&gt;Мой подход&lt;/h2&gt;

&lt;p&gt;В 2019 году, пока работал в toptal, попробовал схему с графом, которая прижилась и которую использую до сих пор. Идейно подход напоминает &lt;a href=&quot;https://en.wikipedia.org/wiki/Directed_acyclic_graph&quot;&gt;DAG&lt;/a&gt;, который используется как визуализатор задач в пайплайнах CI/CD или ETL. Единственное отличие, граф рисую руками, вместо использования &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;as a code&lt;/code&gt; подхода.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/airflow-dag-visualizator.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Airflow DAG visualizator, который «рисует» шаги data flow в виде графа, где визуально понятно какая задача за какой вызывается и какой статус у каждой задачи&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Главный плюс подхода – работает в любом инструменте. Я чаще использую lucidchart, но можно взять draw.io или аналоги, возможно даже diagram as code подойдет (не пробовал). Главное, чтобы выполнялись следующие условия:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Можно рисовать квадраты разных цветов;&lt;/li&gt;
  &lt;li&gt;Есть возможность связывать стрелками квадраты между собой;&lt;/li&gt;
  &lt;li&gt;Можно добавлять отдельный элемент для комментариев (в идеале стикер);&lt;/li&gt;
  &lt;li&gt;Наличие отдельных вкладок для версионирования (об этом дальше);&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Сам процесс работы с графом состоит из трех шагов:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Планирование;&lt;/li&gt;
  &lt;li&gt;Наблюдение;&lt;/li&gt;
  &lt;li&gt;«Рефлексия»;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Давайте, на примере выноса кода в отдельный сервис, пройдем по каждому из шагов&lt;/p&gt;

&lt;h3 id=&quot;шаг-1-планирование&quot;&gt;Шаг 1: планирование&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;Предупреждаю: скорее всего сам план будет не корректен, но у меня цель идею показать, а не «правильно» спланировать работу.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Первым делом придется понять что за задачи нужно выполнить. В примере выносом кода в отдельный сервис можно сразу сказать три задачи которые необходимо выполнить:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Поднять новый и пустой сервис&lt;/li&gt;
  &lt;li&gt;Перенести логику в сервис&lt;/li&gt;
  &lt;li&gt;Перевести трафик с монолита на новый сервис&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;В виде графа это будет выглядеть следующим образом:&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/example-step-1-base.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Каждый шаг – отдельная нода графа, связи – показывают что за чем выполнять по плану&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Дальше наступает этап анализа, когда оказывается, что каждый из трех шагов состоит из специфичных действий: поднять новый сервис включает в себя поднятие необходимой базы, инстанса приложения, создания репозитория, настройку CI/CD, observability. При этом, без observability перевод трафика не будет иметь смысл.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/example-step-1-first-improvements.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Раскрываем «большие» задачи на конкретные шаги, которые необходимо выполнить&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Когда будут +- понятные задачи, советую отдельно подумать о двух вещах: интеграции и валидации.&lt;/p&gt;

&lt;p&gt;Под интеграции попадает все, что связывает два элемента вместе: вызов внешнего API, перенос данных из базы в базу, вызов API внутреннего сервиса, перенос данных из старой схемы в новую схему в рамках одной бд, наполнение данными нового сервиса/новой базы и так далее. Об интеграциях забывают в планировании, но как подсказывает практика, тут больше всего риска провалиться: сорвать срок, получить не консистентность и затянуть с работой. &lt;/p&gt;

&lt;p&gt;А под валидации попадает вся левая часть v-model: валидация адекватности данных, которые перенесли, валидация что решение работает, валидация что сервис правильно раскатался, валидация интеграций и так далее. Также как и в интеграциях, валидации забываются и тут много рисков/проблем, которые чаще выстреливают, чем нет.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/example-step-1-integration-and-validation.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Белые квадраты – интеграции и валидации о которых забывают, но которые не менее важны, чем написание кода и деплой&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Как сделаете план, важно согласовать шаги с командой. Тут два ключевых стейкхолдера: те, кто будут выполнять работу (чаще разработчики, тестировщики, дизайнеры и так далее) и менеджеры, которые будут выбивать ресурсы под работу. Возможно граф станет еще больше или часть задач изменится, это нормально. Важно, чтобы каждый согласился работать по представленному плану.&lt;/p&gt;
&lt;h4 id=&quot;советы&quot;&gt;Советы&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Есть риск скатиться в дробление задач на супер мелкие куски. Не вижу ничего плохого в этом, особенно если опыта мало. Подобные задачи можно схлопнуть или выкинуть на ревью. Единственное исключение – низкоуровневые технические задачи, которые стоит оставлять только если задачи супер критичные для проекта. Если нет, лучше использовать чеклисты для валидации (например сделать чеклист для изменения схемы бд с шагами и проверками);&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Всегда&lt;/strong&gt; (это важно) думайте о необходимых интеграциях и валидациях, без которых проект не запустится. Помните, что есть разница между сделать и заставить работать без ошибок;&lt;/li&gt;
  &lt;li&gt;Согласование такой же необходимый шаг, как и создание графа. Если придти и с ноги сказать кто, что и как делать будет – велик риск саботажа. Плюс другие люди могут указать о том, что вы забыли добавить или что часть работы можно выкинуть;&lt;/li&gt;
  &lt;li&gt;Один из возможных «smell-ов» по задачам – появление задачи, которая ни с чем не связана. Т.е. у задачи может быть либо входящая, либо исходящая связь (либо две сразу), но полное отсутствие стрелок является знаком, что что-то не так и стоит посмотреть внимательно (исключение – задачи в будущее, которые важно помнить, но непонятно когда и как их делать);&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;шаг-2-наблюдение&quot;&gt;Шаг 2: наблюдение&lt;/h3&gt;

&lt;p&gt;Нудный и в тоже время важный шаг. Каждый спринт встречаемся с исполнителями, проходим по каждой задачи из графа, оставляем комментарии и добавляем новые задачи, если оказалось что они нужны. Плюс отмечаем что было сделано и что в работе на момент ревью. Для этого использую цвета: зеленый – сделали, желтый – в работе, красный – отменили.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/real-example-full-graph.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Реальный граф связанный с рефакторингом сервиса. Комментарии оставляю как стикер, тут нет стандартизации. К сожалению шакально по причине NDA, но идею по картинке понять можно&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Тут важно сохранять прошлую версию графа отдельно. Для этого делаю копию, ставлю текущую дату (версию) и заполняю скопированный граф&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/real-example-graph-versions.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Каждая вкладка – новая версия графа, которая изменяется&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Благодаря такому версионированию, можно ретроспективно посмотреть как долго задачи делаются, что добавилось нового и исследовать процесс выполнения работы.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;https://leonardo.osnova.io/6c44e586-3769-4c22-4270-a326d823ea8c/-/format/mp4#t=0.1&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;В 2020 году, Самат &lt;a href=&quot;https://vc.ru/services/151374-s-pomoshyu-diagramm-mozhno-obyasnit-chto-ugodno-tem-bolee-dlya-etogo-est-klassnye-instrumenty&quot;&gt;написал статью&lt;/a&gt;, где показывал граф выполнения работ (в самом низу), видео как раз из статьи&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Кроме отметок по задачам, использую секцию «Проблемы/вопросы/комментарии», куда добавляю все, о чем говорят исполнители. В будущем секция помогает в анализе и ретро.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/real-example-pros-cons-ideas.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Пример секции «Проблемы/вопросы/комментарии» из проекта выше. Красное – проблемы, зеленое – комментарии, желтым обозначаю вопросы&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;По итогу, получаем гибкий инструмент, который можно использовать для ответа «в каком статусе проект» и «почему долго делается ХХХ?!».&lt;/p&gt;

&lt;h4 id=&quot;советы-1&quot;&gt;Советы&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Как я уже сказал - наблюдение важный шаг. Но при этом и сложный из-за регулярности и желания пропустить и забить. Советую хотя бы раз попробовать выполнить проект не забивая на этот шаг и после уже решать, подходит подход или нет;&lt;/li&gt;
  &lt;li&gt;Версионирование графа – ключ к успеху, особенно для шага с анализом;&lt;/li&gt;
  &lt;li&gt;Не бойтесь добавлять новые задачи. Невозможно сразу описать план идеально. В моей практике, в итоговой версии графа оказывается на ~40% больше задач, чем в изначальной версии;&lt;/li&gt;
  &lt;li&gt;Секция с проблемами не обязательна, но помогает сохранить контекст на будущее;&lt;/li&gt;
  &lt;li&gt;У каждого стейкхолдера должен быть доступ к графу в любое время. Разработчики смогут быстро посмотреть что делать дальше, а у бизнеса появится обсервабилити над проектом в любой необходимый момент времени;&lt;/li&gt;
  &lt;li&gt;В теории, можно раз в неделю открывать «джиру» и отмечать самому что в работе, а что планируется. Но у такого подхода есть минус – шаги не просматриваются исполнителями и нет контакта, благодаря которому можно поговорить о косяках в планировании или проблемах в реализации;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;шаг-3-рефлексия&quot;&gt;Шаг 3: «рефлексия»&lt;/h3&gt;

&lt;p&gt;Это опциональный пункт. Идея в том, что по завершению проекта, любят устраивать ретро. Если проект длится больше 6 месяцев – шансы вспомнить что было в начале нулевые. Но благодаря графу можно быстро посмотреть как долго делались задачи, выписать какие проблемы возникли (с решениями) и посмотреть на сколько ожидания разошлись с реальной работой.&lt;/p&gt;

&lt;h2 id=&quot;advanced-использование-графа&quot;&gt;Advanced использование графа&lt;/h2&gt;

&lt;p&gt;Чтобы накидать ещё больше пользы в ответ, решил еще добавить секцию связанную с анализом. Тут будут идеи из личного опыта, поэтому не ждите хардскилового менеджмента.&lt;/p&gt;

&lt;h3 id=&quot;поиск-проблем&quot;&gt;Поиск проблем&lt;/h3&gt;

&lt;p&gt;В секции с шагом планирования упоминались «висящие» задачи. Кроме этого есть еще один «smell». Связан он с ситуацией, когда задача блокирует другие задачи, например вот так:&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/example-task-blocker.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Центральная задача блокирует правые. При этом, центральная задача ждет левые&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Проблема тут в том, что нельзя распараллелить выполнение работ из-за центрального блокера. Это не всегда плохо, но советую подумать, как можно блокер разбить на несколько задач, которые позволят разблокировать параллельность.&lt;/p&gt;

&lt;h3 id=&quot;как-срокиресурсы-считать&quot;&gt;Как сроки/ресурсы считать&lt;/h3&gt;

&lt;p&gt;Сразу скажу, делал такое 2 раза в жизни, но оба раза срабатывало. Идея в том, что сначала проставляется оценка задачам, после чего планируется, сколько команд надо для работы. В результате можно предположить сколько людей и в какой последовательности будут происходить работы. Благодаря чему заранее выбить капасити каждой команды и предположить сколько времени займет работа (немного точнее, чем просто «пальцем в небо»).&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/example-resource-planning.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Что бы вынести сервис из монолита нужно 4 команды (каждый цвет – отдельная команда), причем левые три команды могут работать параллельно, а последняя нужна только в самом конце и до реализации бизнес логики может отдыхать&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Подход полезен в двух случаях: когда надо посчитать «пальцем в небо» стоимость и когда проект реализуется сразу несколькими командами и нужно кросс командное взаимодействие.&lt;/p&gt;

&lt;h3 id=&quot;как-понять-почему-по-срокам-не-укладывайтесь&quot;&gt;Как понять, почему по срокам не укладывайтесь&lt;/h3&gt;

&lt;p&gt;Специально для ситуаций, когда бизнес не понимает, почему изначальный коммит был на полгода, а прошло уже 2 года и проект не приносит денег. Благодаря графу можно наглядно показать как увеличился пул задач или какие задачи долго висели в блоке. Судя по опыту, это выглядит намного нагляднее для не-менеджеров, чем графики «джиры».&lt;/p&gt;

&lt;p&gt;Плюс, если за 2-3 спринта задачи только добавляются в граф, а прогресса нет – время бить тревогу и пинать менеджмент/бизнес, что проблемы начались.&lt;/p&gt;

&lt;h3 id=&quot;используем-реальный-анализ-графов&quot;&gt;Используем реальный анализ графов&lt;/h3&gt;

&lt;p&gt;Так как это граф, можно применить научные методики анализа из теории графов. Но тему не раскручивал, поэтому оставлю идею для самостоятельного изучения. Если что-то придумаете, напишите пожалуйста, буду рад обсудить.&lt;/p&gt;
&lt;h3 id=&quot;как-использовать-project-management-tools-с-таким-графом&quot;&gt;Как использовать project management tools с таким графом&lt;/h3&gt;

&lt;p&gt;Если взять &lt;a href=&quot;https://pepegramming.site/questions/data-model/#data-modelling&quot;&gt;идею conceptual/logical/physical data models&lt;/a&gt;, то можно представить граф как концептуальную модель, PM tool как логическую, а реализацию в виде кода как физическую&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-16-graph-as-a-project-managment-tool/conceptual-logical-phisical-models.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Наглядное сравниение каждой data model и планирования работы&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Из этого сравнения получается, что есть условный «эпик», который описывается графом. Каждая нода графа – отдельный проект в «джире», а каждый таск из проекта – отдельный PR/MR, который на шаг ближе закрывает эпик.&lt;/p&gt;

&lt;p&gt;Благодаря такому разделению, можно использовать viewpoints для каждого стейкхолдера: список задач для команды, гант диаграмму по эпику, статус проекта для бизнеса, задачи для конкретного разработчика и так далее.&lt;/p&gt;

&lt;p&gt;А если используете &lt;a href=&quot;https://habr.com/ru/articles/831922/&quot;&gt;трассировку требований&lt;/a&gt;, сможете линковать между собой. Единственный минус подхода, для графа нет автоматизации.&lt;/p&gt;

&lt;h2 id=&quot;плюсы-и-минусы-использования-графа-для-планирования&quot;&gt;Плюсы и минусы использования графа для планирования&lt;/h2&gt;
&lt;p&gt;Начну с плюсов:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Появляется хоть какая-то системность в планировании и выполнении проекта. Благодаря чему каждый из стейкхолдеров может рассматривать &lt;a href=&quot;https://creatime.me/MediaLibrary/UchebnyeMaterialy-2/Stati/PodsistemyI&quot;&gt;либо подсистемы либо надсистемы&lt;/a&gt; в зависимости от собственных интересов;&lt;/li&gt;
  &lt;li&gt;Лично доволен таким подходом, за пять лет проблем не было;&lt;/li&gt;
  &lt;li&gt;Когда проектов больше пяти – помогает быстро получить контекст в каком состоянии реализация каждого;&lt;/li&gt;
  &lt;li&gt;Судя по опыту, бизнес любит такую наглядность. Разработчики страдают от того, что сложно хайлевел задачи декомпозировать и понять что за чем – поэтому декомпозицию можно обсудить заранее. Пару раз ребята говорили спасибо, ибо понимали что их дальше ждет и могли заранее подготовить код к будущей работе;&lt;/li&gt;
  &lt;li&gt;Из-за концептуальности и простоты решения – супер гибкое решение. Выбираете удобный вам инструмент для диаграмм и работаете. Только помните, что в случае вайтбордов придется решить, как версионировать графы. Плюс, с добавлением трассировки требований, можно быстро делать кросс линки между задачами и другими артефактами работы;&lt;/li&gt;
  &lt;li&gt;Концептуальный план делается быстро и легко правится. После можно сделать «логический» план в виде задач или эпиков в джире и сразу начать работать, вместо того, что бы тратить время на реализацию концептуального плана в PM tool;&lt;/li&gt;
  &lt;li&gt;Хорошо показывает себя в проектах, где есть четкая цель, которая не поменяется через пол года и которую долго делать. Например, когда знаете, что надо вынести сервис, отрефакторить кусок кода или реализовать фичу с определенным DoD. Один раз сделали, знаете конец и дальше работаете, раз в спринт сверяясь;&lt;/li&gt;
  &lt;li&gt;Судя по опыту, работает для ретро лучше, чем список задач из джиры (возможно ошибка выжившего). Связано с тем, что подход добавляет концепцию «журнала» связанного с проблемами, хорошими вещами и вопросами. После чего, на ретро, открываем нужный спринт и смотрим, что там происходило;&lt;/li&gt;
  &lt;li&gt;Не совсем о подходе, но скорее в целом о полном плане работ: включается &lt;a href=&quot;https://fs.blog/amateurs-professionals/&quot;&gt;мышление второго порядка&lt;/a&gt;. Особенно, если план валидировать через результат каждого шага + вопроса “что произойдет после этого”;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;После плюсов может показаться, что инструмент серебряная пуля, но минусов у графа тоже много:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;К концу релиза начинается каша и велик риск забить на диаграмму. Нужен высокий уровень самоконтроля и постоянно пушить исполнителей. Из этого следует главный минус – без контроля и ревью, подход не работает;&lt;/li&gt;
  &lt;li&gt;Не сработает, когда высокая неопределенность в работе. Т.е. когда сделав задачу, планы меняются и становятся другими, например сегодня выносите сервис, а завтра оказывается, что денег больше нет и надо гипотезы делать по две штуки в день;&lt;/li&gt;
  &lt;li&gt;Это придуманный подход, его нет нигде. Поэтому допускаю проблемы с объяснением и обучением, так как нет описания. Т.е. кроме куска из курса о системах и этого текста, в интернете информации нет (если ошибаюсь и знаете аналоги, буду рад ссылке);&lt;/li&gt;
  &lt;li&gt;Придется заморочиться с трассировкой требований, если нужна интеграция с проектной документацией. Это лишняя работа и цена;&lt;/li&gt;
  &lt;li&gt;Подход придется продавать бизнесу, менеджерам и исполнителям работы. Продажа подхода – одна из причин, почему появился этот текст;&lt;/li&gt;
  &lt;li&gt;Из инструментов – кривые плагины для конфлюенса и аналогов, либо делать руками. Если используете диаграммы - нет фильтрации по проектам/командам и автоматической генерации других viewpoints;&lt;/li&gt;
  &lt;li&gt;Подход не о сроках и датах. Если сроки важны, придется либо делать отдельный viewpoint (например ганта), либо использовать другой инструмент;&lt;/li&gt;
  &lt;li&gt;Менеджерам будет не хватать асайнов на людей, фильтрации и сроков/статусов;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;выводы&quot;&gt;Выводы&lt;/h2&gt;

&lt;p&gt;Использование подобного графа оправданно, если необходим «концептуальный» уровень для планирования проектов, а условная «джира» не справляется. Так как подход максимально гибок, можно использовать любые инструменты для диаграмм или вайтбордов (можно даже лист бумаги и ручку взять). Важно помнить, что стоит делать квадраты похожими на проект из GTD и следить за связями. При этом, кроме работы над планом, стоит потратить время на регулярное обновление статуса по проекту, что в будущем окупится аналитикой и ретро.&lt;/p&gt;

&lt;p&gt;Ну и еще раз напишу, что описанный подход планирования и слежения за проектами не единственный и не серебрянная пуля. Ну и помните главное правило: если устраивает текущая ситуация в компании – лучше ничего не трогать и не гнаться за новым подходом, ради подхода.&lt;/p&gt;

&lt;p&gt;Кроме этого, если используете «концептуальный» вью в PM инструментах, буду рад, если поделитесь секретом в комментариях. А если захотите воспользоваться описанным выше подходом и останутся вопросы или захотите поделиться фидбеком – буду рад в два раза больше.&lt;/p&gt;

&lt;h2 id=&quot;доп-ссылки&quot;&gt;Доп ссылки&lt;/h2&gt;

&lt;p&gt;Инструменты, представляющие работу над задачей в виде графа:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://about.i.ntention.app&quot;&gt;Intention&lt;/a&gt;, работает на андроиде и в вебе (если понял правильно). &lt;a href=&quot;https://news.ycombinator.com/item?id=22591311&quot;&gt;Обсуждение на ycombinator&lt;/a&gt; тоже присутствует;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://eyen.fr/taskheat/&quot;&gt;Приложение за которым долго слежу&lt;/a&gt; и от которого были большие ожидания для персональных проектов, но так и не зашло. Возможно попробую еще раз через пару лет. Работает только на apple устройствах и больше о персональных проектах, т.е. конкурент для things3/todois/ticktick/etc;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.gameplan.global&quot;&gt;PM tool, о котором никогда не слышал&lt;/a&gt; (нашел, пока ответ писал). Кажется, что если используете что-то другое, переехать на «нонейм» решение будет сложно;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.easyredmine.com/redmine-wbs-plugin&quot;&gt;Плагин для редмайна&lt;/a&gt; с похожей функциональностью;&lt;/li&gt;
  &lt;li&gt;Два плагина для джиры с похожим функционалом: &lt;a href=&quot;https://marketplace.atlassian.com/apps/1216207/issue-links-viewer&quot;&gt;первый&lt;/a&gt; и &lt;a href=&quot;https://whiteboards.io&quot;&gt;второй&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>Как визуализировать схему базы данных</title>
   <link href="http://pepegramming.site/questions/data-model/"/>
   <updated>2024-08-01T00:00:00+03:00</updated>
   <id>http://pepegramming.site/questions/data-model</id>
   <content type="html">&lt;h2 id=&quot;вопрос&quot;&gt;Вопрос&lt;/h2&gt;

&lt;div class=&quot;question-text&quot;&gt;
  &lt;blockquote&gt;
    &lt;p&gt;«Возникла проблема, что нужно визуализировать данные, но не понятно с чего начать. Что в таких случаях делаешь и какие есть инструменты для этого?»&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/div&gt;

&lt;p&gt;Так как вопрос без конкретики, выделю два случая:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Проект только в голове и хочется понять как связаны данные между собой&lt;/li&gt;
  &lt;li&gt;Проект уже реализован в коде и хочется понять, что из себя представляет схема бд&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Поэтому, вместо короткого ответа «используй ERD», поговорим о каждом из вариантов. Но сначала разберемся с data modelling, благодаря которому можно определить нужный вид диаграммы для задачи.&lt;/p&gt;

&lt;h2 id=&quot;data-modelling&quot;&gt;Data modelling&lt;/h2&gt;

&lt;p&gt;Может показаться, что взять и начать фигачить SQL схему описывающую данные для проекта может быть разумной идеей. На деле это не так:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Так как нет структуры данных в голове, можно запутаться и упороться в вечное редактирование. А если данных много и связей еще больше - получится хаос который не влезет в голову;&lt;/li&gt;
  &lt;li&gt;Полученную модель данных придется валидировать, причем с бизнесом/доменным экспертом. Не разработчикам будет сложно и валидация может затянуться;&lt;/li&gt;
  &lt;li&gt;Когнитивная нагрузка увеличивается: работая с текстом, придется этот текст представить в виде модели в голове и потом обратно, из модели в текст;&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-01-data-model/schema-vs-visualisation.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Слева - схема в dbml, которая представлена в виде диаграммы (справа). Когда разбираешься с новым проектом – мне проще сразу картинкой (моделью) оперировать&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;В целом, выглядит надежно, как швейцарские часы. Поэтому придумали процесс, который назвали &lt;a href=&quot;https://en.wikipedia.org/wiki/Data_model&quot;&gt;data modeling&lt;/a&gt;. Data modeling помогает с определением релевантных для системы данных, связью между этими данными и как данные работают вместе, т.е. создать data model для системы. Главное, что стоит вынести из этой идеи – моделирование можно разбить на три «перспективы»:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Conceptual_schema&quot;&gt;Концептуальная&lt;/a&gt; говорит о том, какие данные используются системой и как данные связаны между собой. Т.е. тут о том, что необходимо бизнесу без привязки к конкретной реализации хранения данных в конкретной бд&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Logical_schema&quot;&gt;Логическая&lt;/a&gt; говорит о том, как данные структурируются в приложении. Т.е. берем любой язык описания схемы (будь то SQL, dbml или еще что) и описываем таблицы/колонки/классы/etc.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Physical_schema&quot;&gt;Физическая&lt;/a&gt; говорит о том, как данные физически храниться будут. Т.е. берем логическое описание и говорим где данные будут находиться физически и как все будет работать в реальности;&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-01-data-model/conceptual-vs-logical-models.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Сравнение концептуальной (правая) и логической (левая) схем, где пример из самого начала. Возможно, я сделал концептуальную модель не корректно, но задача показать идею, а не сделать корректную модель&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;При использовании концептуальной модели данных можно отказаться от «технической» информации и оставить только необходимое для реализации бизнесовой модели. Т.е. можно не запариваться с pk, fk и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;created_at&lt;/code&gt; для каждого объекта и не думать о таблицах. Так, в примере выше, указан продукт как «элемент», к которому привязаны отдельные «элементы»: цена, тег и статус. Эта информация необходима для бизнес логики, хотя в реальности, если опуститься на логический уровень – данные оказываются в одной таблице.&lt;/p&gt;

&lt;p&gt;Теперь, используя информацию о data modeling, можно вернуться к оригинальному вопросу.&lt;/p&gt;

&lt;h2 id=&quot;случай-1-проект-только-в-голове-и-хочется-понять-как-связаны-данные-между-собой&quot;&gt;Случай 1: Проект только в голове и хочется понять как связаны данные между собой&lt;/h2&gt;

&lt;p&gt;Возможно бизнес с нуля делает систему, либо же нужно разобраться в уже работающей бизнес логике (доменной модели). Для этого придется разбираться с данными: какие элементы, как элементы связаны. Если в этот момент думать о том, где какая таблица будет и что в этой таблице должно находиться – выглядит как доп нагрузка которая усложняет работу. Поэтому для первого случая концептуальное представление предпочтительнее: меньше когнитивная нагрузка, проще работать, можно показать бизнесу не объясняя что это за &lt;a href=&quot;https://www.datensen.com/blog/er-diagram/one-to-many-relationships/&quot;&gt;вилка&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;виды-нотаций-концептуальных-моделей&quot;&gt;Виды нотаций концептуальных моделей&lt;/h3&gt;

&lt;p&gt;Тут список может быть большой, опишу только то, что сам знаю и видел. Подробно на каждой нотации останавливаться не буду, оставлю это на самостоятельное изучение.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://studme.org/77224/informatika/notatsiya_idef&quot;&gt;Нотация IDEF 1х&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://studme.org/77225/informatika/notatsiya_uml&quot;&gt;PlantUml&lt;/a&gt;, тут используется &lt;a href=&quot;https://en.wikipedia.org/wiki/Class_diagram&quot;&gt;class diagram&lt;/a&gt;, что сомнительно, но для общего развития пусть будет.&lt;/li&gt;
  &lt;li&gt;Cтоит упомянуть &lt;a href=&quot;http://www.modelsphere.com/org/index.html&quot;&gt;Open ModelSphere&lt;/a&gt;, это oss инструмент, который помогает с моделированием данных не только концептуально, но и логически/физически
 
Отдельно хочется рассказать еще о двух нотациях:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Первая нотация – &lt;a href=&quot;https://en.wikipedia.org/wiki/Entity–relationship_model&quot;&gt;ER model&lt;/a&gt; (иногда встречается как &lt;a href=&quot;https://studme.org/77222/informatika/notatsiya_pitera_chena&quot;&gt;нотация Питера Чена&lt;/a&gt;) и тут важно не путать с ER diagram. Модель создана Питером Ченом в 1976 году для абстрактного описания данных. При этом, модель предоставляет абстракции для концептуального/логического/физического моделирования. Интересный факт: эта одна из нотаций, которые повлияли на UML.&lt;/p&gt;

&lt;p&gt;Вторая – &lt;a href=&quot;https://martinfowler.com/books/ap.html&quot;&gt;нотация концептуальной модели Мартина Фаулера из книги&lt;/a&gt;, о которой преступно мало знают.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-01-data-model/martin-fowler-notation.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Так выглядит нотация используемая Фаулером, она описана прямо на первых страницах книги&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Что выбрать – решайте сами. Расскажу о том, что сам использую и почему редко использую описанные выше модели.&lt;/p&gt;

&lt;h3 id=&quot;что-сам-использую&quot;&gt;Что сам использую&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://tough-roadway-bb5.notion.site/1-1-6adfeb2e07eb4269b5966ffb742d7fad#34413c7cc27b4e1da6ee31177875b93b&quot;&gt;Я использую сильно упрощенную нотацию, состоящую только из квадратов и стрелок&lt;/a&gt;, которую сам и «придумал». При этом, вместо использования сложных видов стрелок, подписываю вид связи который нужен (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;has_one&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;has_many&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;optional_has_one/many&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;many_to_many&lt;/code&gt;). Плюс использую цветовое обозначение для данных, которые используются в разных контекстах.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-01-data-model/data-model-example.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Пример модели из рабочего проекта. Тут кусок модели, &lt;a href=&quot;https://vc.ru/fedorandsamat/1103649-kak-my-perezapuskali-medicinskuyu-informacionnuyu-sistemu&quot;&gt;связанный с работой дантистов&lt;/a&gt;&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Такой выбор обусловлен двумя причинами:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Концептуальную модель приходится валидировать с бизнесом/доменными экспертами. Чем сложнее нотация, тем больше шансов, что человек запутается. Плюс грузить и без этого занятых людей так себе подход.&lt;/li&gt;
  &lt;li&gt;Внимательность – не обо мне, поэтому с большим шансом запутаюсь или пропущу стрелку/форму и по итогу получится фигня. Рисковать и проверять себя по 10 раз не хочется.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Если в компании уже есть стандарт, либо хотите использовать распространенный стандарт – лучше забыть эту часть текста и использовать то, что уже принято. Если ничего такого нет, возможно стоит скопировать мое решение, а после, если этого окажется мало, выбрать любую из описанных выше нотаций.&lt;/p&gt;

&lt;h3 id=&quot;советы-для-моделирования-данных-не-схемы-бд&quot;&gt;Советы для моделирования данных (не схемы бд)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Забудьте о таблицах и реализации в бд. Начните с данных, которые необходимы для работы бизнес модели. Главная причина такого категоричного совета – проще замапить корректную концептуальную модель на реализацию конкретной базы данных, чем упороться с реализацией и потерять важные данные. Это может привести к тому, что решение не будет бизнес задачу решать, а будет подстраиваться под техническое решение, вокруг которого зацепитесь;&lt;/li&gt;
  &lt;li&gt;Вытекает из первого совета: в концептуальной модели не нужны данные, которые окажутся в базе данных. Поэтому о &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pk&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fk&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;created_at&lt;/code&gt;, etc можно забыть. Только если это не часть доменной модели;&lt;/li&gt;
  &lt;li&gt;Не важно какую нотацию выбрали, модель без легенды – деньги на ветер;&lt;/li&gt;
  &lt;li&gt;Валидируете модель с бизнесом/доменным экспертом;&lt;/li&gt;
  &lt;li&gt;Между дублированием элементов и уменьшением стрелок – выбирайте дублирование. Так можно снизить когнитивную нагрузку, которая появится из-за стрелочного хаоса. По этой же причине старайтесь избегать пересечения стрелок;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;С моделированием разобрались. Давайте поговорим о генерации картинок из схемы бд.&lt;/p&gt;

&lt;h2 id=&quot;случай-2-проект-уже-реализован-в-коде-и-хочется-понять-что-из-себя-представляет-схема-бд&quot;&gt;Случай 2: Проект уже реализован в коде и хочется понять, что из себя представляет схема бд&lt;/h2&gt;

&lt;p&gt;В данном случае, если нужна концептуальная модель – инструментов не знаю, к сожалению. Поэтому, для проектов с реализованной схемой бд, рисую концептуальные модели «руками».&lt;/p&gt;

&lt;p&gt;Но если хватит логической модели, можно найти решение. Из того что знаю – ER diagram (которая, является подмножеством ER model). Существует новомодный dbml, который тоже использовал. Еще стоит упомянуть &lt;a href=&quot;https://studme.org/77223/informatika/notatsiya_martina_crows_foot&quot;&gt;Нотацию Мартина (Crow’s Foot)&lt;/a&gt;, но в живую не наблюдал. Если знаете другие варианты – буду рад комментариями, ибо самому интересно, а быстро нагуглить альтернативы не вышло.&lt;/p&gt;

&lt;p&gt;Для генерации «картинки» я использую следующие подходы:&lt;/p&gt;

&lt;h3 id=&quot;генерация-модели-из-кода&quot;&gt;Генерация модели из кода&lt;/h3&gt;

&lt;p&gt;В эту секцию входят:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;инструменты diagram as a code: &lt;a href=&quot;https://graphviz.org/Gallery/neato/ER.html&quot;&gt;graphiz&lt;/a&gt;, &lt;a href=&quot;https://mermaid.js.org/syntax/entityRelationshipDiagram.html&quot;&gt;mermaid&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;библиотеки для разных языков (&lt;a href=&quot;https://github.com/drivendataorg/erdantic&quot;&gt;python&lt;/a&gt;, &lt;a href=&quot;https://github.com/voormedia/rails-erd&quot;&gt;ruby&lt;/a&gt;, &lt;a href=&quot;https://github.com/fuelen/ecto_erd&quot;&gt;elixir/ecto&lt;/a&gt;, &lt;a href=&quot;https://github.com/gmarik/go-erd&quot;&gt;golang&lt;/a&gt;, &lt;a href=&quot;https://www.npmjs.com/package/prisma-erd-generator&quot;&gt;js/prisma&lt;/a&gt;, etc) которые под капотом используют graphiz.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;С вероятностью в 99% там будет ERD. А подход подойдет в двух случаях:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Если схема данных меньше ~15 таблиц и хочется быстро подключить генератор, а после забыть и получать каждый релиз новый артефакт;&lt;/li&gt;
  &lt;li&gt;Если модель нужна для поста или показать идею;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Плюсы:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Работает для схем, где таблиц меньше ~15 или когда связей мало между таблицами;&lt;/li&gt;
  &lt;li&gt;Библиотеки работают из коробки и легко настраиваются;&lt;/li&gt;
  &lt;li&gt;Если говорим о библиотеках – нет проблем с обновлением схемы после изменений, так как генерируется новый файл;&lt;/li&gt;
  &lt;li&gt;Легко шарить между коллегами. Отправляем картинку в чат, добавляем в репозиторий или конфлюенс/ноушен/etc;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Из минусов:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Нельзя поменять положение элементов или связей. А автоматическая генерация не поддается логике;&lt;/li&gt;
  &lt;li&gt;На больших схемах получается не читаемая каша. Особенно, когда дело касается связей;&lt;/li&gt;
  &lt;li&gt;Генерируется векторная картинка, если схема увесистая – может шакалить;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;генерация-erd-в-инструментах-для-диаграм&quot;&gt;Генерация ERD в инструментах для диаграм&lt;/h3&gt;

&lt;p&gt;Lucidchart предоставляет &lt;a href=&quot;https://www.lucidchart.com/pages/examples/er-diagram-tool&quot;&gt;инструмент, который генерирует ERD по загруженной схеме бд&lt;/a&gt;. Дальше получаете диаграмму, в которой можно двигать элементы, стрелки, добавлять новые элементы, менять цвета и делать что угодно.&lt;/p&gt;

&lt;p&gt;Draw.io реализовали &lt;a href=&quot;https://www.drawio.com/doc/faq/sql-plugin&quot;&gt;аналогичный инструмент&lt;/a&gt;. Только для работы придется вставлять SQL код. После, с полученной схемой, также можно производит манипуляции с диаграммой.&lt;/p&gt;

&lt;figure class=&quot;image&quot;&gt;
  &lt;img src=&quot;/public/images/questions/2024-08-01-data-model/erd-bad-example.jpg&quot; alt=&quot;dbml: code and visualisation&quot; /&gt;
  &lt;figcaption&gt;&lt;p&gt;Пример сгенерированной ERD в lucidchart. Получи такое картинкой – сразу бы отказался от проекта&lt;/p&gt;
&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;Плюсы:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;В отличии от векторной картинки – можно делать с полученной моделью что угодно;&lt;/li&gt;
  &lt;li&gt;Если не хватит сгенерированных элементов – можно добавить (например стикеры и комментарии);&lt;/li&gt;
  &lt;li&gt;Если схема большая – можно двигать каждую связь или элемент, плюс выручает поиск по модели;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Из минусов:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Могут теряться связи между элементами, особенно если связи указаны в коде, но не учтены в схеме бд. Пару раз попадался на эту уловку и приходилось руками достраивать модель, что малоприятно;&lt;/li&gt;
  &lt;li&gt;Хоть с диаграммой можно делать что угодно, но первичная генерация хаотична. Поэтому для «наведения порядка» придется самостоятельно двигать элементы;&lt;/li&gt;
  &lt;li&gt;Специфичный импорт, из-за чего придется под новую версию схемы делать новую диаграмму. А если добавили что-то кастомное, придется дублировать руками;&lt;/li&gt;
  &lt;li&gt;Шарить модель может быть проблемно, особенно если используете lucid и душит жаба платить за кучу людей (но для конфлюенса был плагин);&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Заметка: помните, что генераторы ERD присутствуют не везде. Например, &lt;a href=&quot;https://miro.com/diagramming/er-diagram/&quot;&gt;в miro нет ERD генераторов&lt;/a&gt;, вместо этого, получите только элементы для того, чтобы самостоятельно рисовать модель. &lt;/p&gt;

&lt;h3 id=&quot;использование-dbml&quot;&gt;Использование dbml&lt;/h3&gt;

&lt;p&gt;Персональное открытие прошлого года. Вместо рассказа, &lt;a href=&quot;https://dbdiagram.io/d&quot;&gt;лучше посмотреть самостоятельно&lt;/a&gt; (в верхнем левом углу, где лого, можно загрузить advanced sample, который использовался в примерах в начале статьи).&lt;/p&gt;

&lt;p&gt;При этом, так как dbml схема типизирована, можно написать конвертер из erd в dbml и получить генерацию схемы из кода (делал так для &lt;a href=&quot;https://github.com/voormedia/rails-erd&quot;&gt;erd-rails&lt;/a&gt; генератора). После, вставляем схему в редактор и изучаем схему баз данных.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Плюсы:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Из-за динамичности, можно двигать элементы, что работает с большими схемами;&lt;/li&gt;
  &lt;li&gt;Diagram as a code. Можно &lt;a href=&quot;https://dbml.dbdiagram.io/cli#convert--a-sql-file-to-dbml&quot;&gt;генерировать dbml схему по SQL&lt;/a&gt;, присутствует &lt;a href=&quot;https://github.com/stepanic/parse-server-SCHEMA-to-DBML&quot;&gt;библиотека для монги (не проверял)&lt;/a&gt;, &lt;a href=&quot;https://github.com/hamedsj/DbmlForDjango&quot;&gt;для джанги&lt;/a&gt; библиотека существует;&lt;/li&gt;
  &lt;li&gt;Предпросмотр работает в браузере, не надо ничего ставить локально;&lt;/li&gt;
  &lt;li&gt;Так как генерация из кода – можно избежать ситуации, когда связи не отображаются, так как связей нет в схеме бд, но есть на уровне кода;
  
&amp;lt;/br&amp;gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Из минусов:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Нет нормальной экосистемы. Библиотеки придется писать самому, в частности для мало популярных языков;&lt;/li&gt;
  &lt;li&gt;Еще один язык описания схемы, который придется изучить;&lt;/li&gt;
  &lt;li&gt;Если хотите хранить и смотреть модели командой, придется платить. Хотите селфхостед – на 2023 год находил аналоги, но каждый оставлял желать лучшего;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;генерация-из-редактораide&quot;&gt;Генерация из редактора/IDE&lt;/h3&gt;

&lt;p&gt;Так как всю жизнь просидел в vim, без возможности выхода, то особо ничего сказать о генерации схем из редактора и инструментов для этого. Знаю, что инструменты существуют и пользователи jetbrains &lt;a href=&quot;https://www.jetbrains.com/help/datagrip/creating-diagrams.html#db_diagrams&quot;&gt;могут смотреть на схему не выходя из редактора&lt;/a&gt;. Лучше погуглить самостоятельно.&lt;/p&gt;

&lt;h2 id=&quot;итоги&quot;&gt;Итоги&lt;/h2&gt;

&lt;p&gt;Если необходимо смоделировать данные, то важно разобраться с целью модели, так как каждое представление закрывает определенные потребности:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Концептуальная модель – говорит о том, какие данные используются системой и как данные связаны между собой. Подойдет если важно понять что за данные нужны в бизнес логике и как данные связаны между собой;&lt;/li&gt;
  &lt;li&gt;Логическая модель – говорит о том, как данные структурируются в приложении. Поможет описать или посмотреть на схему бд. Можно сгенерировать автоматически;&lt;/li&gt;
  &lt;li&gt;Физическая модель – говорит о том, как данные физически храниться будут. Сам не использовал, но допускаю, что поможет в инфраструктурных документах;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Если нужно визуализировать схему бд, то тут два варианта: для мелких схем или для примеров лучше взять генераторы или diagram as a code инструменты, а для больших схем лучше либо взять инструменты для диаграм, либо посмотреть в сторону dbml, который можно использовать и в качестве генератора.&lt;/p&gt;

&lt;h2 id=&quot;что-еще-почитать-по-теме&quot;&gt;Что еще почитать по теме&lt;/h2&gt;

&lt;p&gt;Если тема data model заинтересовала, собрал четыре ссылки, по которым можно погрузиться в тему глубже. &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;[en] В статье не рассказывал про archimate. Хотя там так же &lt;a href=&quot;https://eaprincipals.com/data-modeling-with-archi/&quot;&gt;можно сделать нужную data model&lt;/a&gt;. Если используете archi - ничего нового не узнаете, скорее всего;&lt;/li&gt;
  &lt;li&gt;[en] &lt;a href=&quot;https://www.mongodb.com/basics/data-modeling&quot;&gt;Статья из блога mongoDB, в которой рассказывается data modelling&lt;/a&gt;. В тексте найдете описание подхода, виды представлений, описание процесса, советы и еще больше инструментов и так далее;&lt;/li&gt;
  &lt;li&gt;[en] &lt;a href=&quot;https://www.thoughtspot.com/data-trends/data-modeling/conceptual-data-model-examples&quot;&gt;Статья о том, как сделать концептуальную модель&lt;/a&gt;, какие виды есть и в чем ее преимущества;&lt;/li&gt;
  &lt;li&gt;[en] Серия статей о визуализации бд. По &lt;a href=&quot;https://minimalmodeling.substack.com/p/visual-language-and-database-visualization&quot;&gt;ссылке третья часть&lt;/a&gt;, где упоминаются разные приложения для визуализации: MySQL Workbench,  Anchor,  TLDraw и Arrows.app;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Ретроспектива: ecommerce</title>
   <link href="http://pepegramming.site/blogposts/retrospection-ecommerce/"/>
   <updated>2020-06-03T00:00:00+03:00</updated>
   <id>http://pepegramming.site/blogposts/retrospection-ecommerce</id>
   <content type="html">&lt;p&gt;Год назад я ушел из healthcare стартапа, который являлся ecommerce для лекарств в штатах. Сразу после ухода я написал черновик с советами самому себе о том, что стоит делать сразу, а на что обратить внимание.&lt;/p&gt;

&lt;p&gt;Черновик забылся на год, но, найдя записи в блокноте, выложил в паблик как ретроспективу основанную на опыте и боли. Каждый пункт -  субъективный опыт и не претендуют на единственно верное решение. Если у вас есть похожие советы связанные с ecommerce - пишите комментарии, хочется собрать целый список. В будущем, можно будет сделать подобные списки и для других видов проектов.&lt;/p&gt;

&lt;h2 id=&quot;ордер-и-цены&quot;&gt;Ордер и цены&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cart&lt;/code&gt; - частный случай &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;order&lt;/code&gt;. Вместо двух сущностей можно взять &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;order&lt;/code&gt;  со статусом &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;created&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Купоны появятся. Делать купон отдельной сущностью - усложняет логику и добавит условий в чекаут и рефанд логику. Сегодня, если нужно будет делать добавить купоны в систему - сделаю купон отдельным айтемом с отрицательной ценой (скидкой).&lt;/li&gt;
  &lt;li&gt;В &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;order_items&lt;/code&gt; линковался на &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;item&lt;/code&gt; и &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;price&lt;/code&gt; из базы. Также, аналитики постоянно меняли цены на товары. Такая ситуация привела к мутациям ордера и было тяжело сказать, что и сколько стоило для ордера годичной давности. А пользователь получал не предсказуемый UX, так как возникала гипотетическая ситуация, что в момент чекаута цена на товар меняется и пользователь заплатит больше или меньше чем ожидает. Сегодня я бы помести в каждый &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;order_item&lt;/code&gt;  JSONB поле для цены которое выглядело следующим образом &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSONB: { added_at: &apos;&apos;, price: ... }&lt;/code&gt;. В таком случае нет непредвиденных мутаций, появляется версионирование данных. К тому же, это больше информации для аналитиков.&lt;/li&gt;
  &lt;li&gt;Датасайнтисты захотят менять цены, используя сложные паттерны расчета цены и кучу условий. Это приводит к постоянным изменениям цен в базе данных. Поэтому сформировалось правило, все что относится к ценам стоит как можно раньше изолировать в отдельный домен, сервис, rails engine, что угодно. Разделять стоит не только на уровне логики, но и на уровне данных. Вариант с JSONB полем - частный случай такого разделения.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;обсервабилити&quot;&gt;Обсервабилити&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Мониторинг и логирование добавляют контроля и скажут что происходит или подскажут где проблема. Покрывать логами и мониторингом каждую строчку  дорого, поэтому top1 кандидаты: все что связанно с деньгами, checkout&amp;amp;refund flow, изменения в данных, интеграции с партнерами, которые приносят деньги. Подход коррелирует с правилом “знайте, что происходит в частях системы, которые приносят деньги”.&lt;/li&gt;
  &lt;li&gt;Работу с деньгами стоит начинать с логов. Если нет ELK или хранилища для логов в котором можно найти информацию без боли - используйте базу данны. Решение для старта - отдельная аудит таблица куда будет попадать информация от платежного шлюза. Такая информация будет полезна как в дебаге, так и аналитикам для создания моделей.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;архитектура&quot;&gt;Архитектура&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Если в системе присутствуют мобильные устройства и другие виды клиентов (например b2b интеграции), значит стоит подумать о версионировании и заложить работу с версиями с самого начала. Кроме версионирования контроллера есть версионирование бизнес логики и версионирование данных.&lt;/li&gt;
  &lt;li&gt;Если клиентов больше двух рекомендую  почитать о &lt;a href=&quot;https://samnewman.io/patterns/architectural/bff/&quot;&gt;BFF паттерне&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;Если событий нет в коде - вероятность появления крайне высока. Sidekiq не предназначен для event driven architecture, хотя помогает отодвинуть переход на новую архитектуру и работает для бэкграунд процессинга или в самом начале работы проекта. Поэтому стоит заложить в имплементацию последующее использование событий вне сайдкика.&lt;/li&gt;
  &lt;li&gt;Код без событий для бизнеса и аналитиков - деньги на ветер. Стоит с самого старта проекта заложить, что события относящиеся к работе бизнеса нужно отправлять. Не обязательно использовать сложные решения или платить за SaaS продукты. Например, в собственных проектах шлю события в телеграм, а некоторые пишу в базу.&lt;/li&gt;
  &lt;li&gt;Kafka как брокер событий с самого старта - провал. Это дорого и очень дорого. Если хоститесь в клауде - sqs или google pub/sub могут стать хорошим началом. Если нет - выбирайте из селфхостед аналогов. Также, стоит сразу подумать о прямой и обратной совместимости данных в событиях, а также о schema registry. Как хак подойдет отдельный репозиторий со схемами событий.&lt;/li&gt;
  &lt;li&gt;Временное остаётся навсегда. Так технология добавленная на 2 спринта осталась в проекте на 2 года.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;данные-и-etl&quot;&gt;Данные и ETL&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;В маркете возникает ситуация, когда регулярно надо загружать новые данные. Пример - цены на товары и сама информация по товарам. Вместо создания rake тасков для загрузки csv в базу, стоит посмотреть на ETL и заложить работу с ним в архитектуру. Из  аналогов можно посмотреть на &lt;a href=&quot;https://github.com/thbar/kiba&quot;&gt;kiba&lt;/a&gt; (написан на руби) и &lt;a href=&quot;https://airflow.apache.org&quot;&gt;Apache Airflow&lt;/a&gt;, написанный на питоне.&lt;/li&gt;
  &lt;li&gt;Желательно подумать о том, как выгружать данные из приложения аналитикам заранее. Шарить дамп БД может оказаться быстрым вариантом, но в долгосрочной перспективе принесет проблемы совместимости между схемой данных в базе и схемой данных у аналитиков. Как альтернативное решение может подойти событийный подход. Но стоит заранее подумать о схеме данных, версионировании и обратной совместимости между версиями.&lt;/li&gt;
  &lt;li&gt;Аналитики хотят видеть динамику по данным и делают из дампов за разные дни список изменений. Событийный обмен данными также поможет в этой проблеме.&lt;/li&gt;
  &lt;li&gt;Если в домене присутствует специфический ID с определенной структурой - сделайте эту структуру на уровне базы и приводите к этой структуре в бизнес логике. Например, у нас был &lt;a href=&quot;https://en.wikipedia.org/wiki/National_Drug_Code&quot;&gt;National Drug Code&lt;/a&gt;. Это строка которая может содержать &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xxxx-xxxx-xx&lt;/code&gt; (10 знаков), &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xxxxx-xxx-xx&lt;/code&gt; (10 знаков), &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xxxxx-xxxx-x&lt;/code&gt; (10 знаков) или &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xxxxx-xxxx-xx&lt;/code&gt; (11 знаков) значения. Спустя год разработки вскрылось, что система содержит три формата этого кода и часть системы поддерживает только десятизначный формат, а на одиннадцатизначном падает с ошибкой. Договорились о стандарте &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5-4-2&lt;/code&gt; (11 знаков), сделали триггер на базу данных, чтобы лефтпадить значение до 11 чисел в строке (недостающие значения забивать нулями) и констрейн в базу данных на не больше 11 символов. В бизнес логике значение через лефтпад приводим к строке 11 символов (с нулями). В таком случае продюсер присылает данные в своем формате, а мы не боимся что в бд будет не валидное значение.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;Нашли опечатку или ошибку? Буду рад если &lt;a href=&quot;https://github.com/2pegramming/2pegramming.github.io/tree/master/posts&quot;&gt;пошлете PR в гитхаб&lt;/a&gt;.&lt;/p&gt;
</content>
 </entry>
 

</feed>
