---
layout: question
title: "Как уменьшить размер события в асинхронных коммуникациях"
categories: questions
published: true
tags:
  - events
  - event_driven
---

## Вопрос

<div class="question-text" markdown="1">
  > Привет!
  >
  > Вопрос: что делать если требуется чтоб в message bus были максимально короткие сообщения?
</div>


Так как вопрос абстрактный, то можно выделить две ситуации, в которой необходимо «короткое» событие:

- Хочу короткие сообщения, потому что так «принято»;
- Есть проблема с брокером/трафиком/деньгами, и нужно решение для уменьшения размера payload в событии. При этом, концептуально событие корректно;

Давайте рассмотрим каждый из вариантов.

<details class="collapse_block">
  <summary class="collapse_block__title">Заумь: душный кусок, который задает понятийный аппарат и который можно пропустить</summary>

  <div class="collapse_block__content" markdown="1">

К сожалению, без духоты, в виде зауми, могут появиться додумки или недопонимания, поэтому лучше договориться на берегу.

Дальше по тексту будут использоваться три термина связанных с событиями, поэтому давайте договоримся на берегу, что подразумевается под каждым из терминов.

- **Событие (event)** – факт того, что произошло в прошлом. Всегда именуется глаголом в прошедшем времени, причем безвозвратным. Например, если что-то покупается в интернет магазине, то событие будет "заказ оформлен";

- **Команда (command)** – действие которое кто-то должен выполнить, обозначаются глаголом в будущем времени. Если вернуться к примеру с заказом, то "оформить заказ", как действие, можно отправить асинхронно. Для команд, текст ниже также валиден;

- **Payload** – кроме названия того, что произошло, нужен и контекст, который добавляет конкретной информации, что именно произошло. Т.е. если мы "оформили заказ", то желательно знать что это за заказ (хотя бы его id), кто это сделал, когда, какие товары были в заказе, какая стоимость (общая и каждого товара) и так далее. Все это является контекстом события, который находится в payload-е события. Для команды аналогично;

```
# Событие в общем виде можно представить так

event ItemAddedToCart { # ItemAddedToCart - название события
  id: int, # тут описываем payload
  # ... 
}

# Команда выглядит так

command AddItemToCart { # AddItemToCart - название команды, которую кто-то выполнит
  id: int, # тут описываем payload
  # ... 
}
```

- **Бизнес событие** – событие которое говорит о том, что какой-то бизнес процесс завершился с каким-то результатом. Если знакомы с EventStorming – оранжевый стикер с событием будет аналогом. Если знакомы с DDD – domain event близок по смыслу;

- **Продьюсинг и консьюминг (producing/consuming)** – терминология из кафки (и аналогов). Producer отправляет события, consumer потребляет. В кролилке любят использовать publisher/subscriber терминологию, что одно и тоже. Но в ответе будет использоваться терминология из кафки;

- **Брокер (message broker)** – очередь/распределенный лог/стриминг платформа используемый для передачи событий из A в B;

Вот об уменьшении payload-а события и поговорим в контексте вопроса.

  </div>
</details>

## Хочу короткие сообщения, потому что так «принято»

Первое, с чего надо начинать, когда дело касается размера payload в событии – определиться с двумя концепциями: `state (fact) vs delta (action) events` и `event granularity`. Чаще эти два понятия даются отдельно и не связывают между собой. Но сегодня особый случай – будем рассматривать концепции в связке.

{%
    include image.html
    url="/public/images/questions/2024-08-30-make-events-small/fine-coarse-state-delta-matrix.jpg"
    description="«Матрица» связи state/delta и event granularity концепций, которую будем использовать дальше"
    altdescription="dbml: code and visualisation"
%}

### State (fact) vs delta (action) events

Существует два подхода к хранению состояния в событиях:

- State (or fact) event – хранит полное состояние агрегата/бизнес события на момент продьюсинга;
- Delta (or action) event – хранит только изменения которые произошли в событие на момент продьюсинга;

{%
    include image.html
    url="/public/images/questions/2024-08-30-make-events-small/state-vs-delta-events.jpg"
    description="Пример двух одинаковых событий: `ItemAddedToOrder`. В delta событии показывается только то, что изменилось, в state – указывается весь «снапшот» `order` агрегата"
    altdescription="dbml: code and visualisation"
%}

> **Дополнение:** считается, что событие не может быть наполовину state и на половину delta. Но в реальности встречал ситуации, когда передавался полный агрегат + изменения только вложенных данных. Поэтому считаю значения не бинарными в этом ответе.

#### Плюсы и минусы state events

**Плюсы**:

- Так как не надо считать состояние из кучи delta событий (которые могут быть разбросаны по разным очередям/топикам), то можно пропустить прошлые события, чтобы получить текущий слепок состояния;
- Если меняется схема событий – проще исправить одно state событие, чем пачку delta;

**Минусы**:

- Cобытие может оказаться слишком большим (наш случай);
- Не понятно что изменилось, если ордеринг событий нарушится. Из-за этого можно будет обновить новые данные на старые и получить не консистентный стейт;
- Если изменения частые, может быть действительно слишком много лишних данных об одном и том же;

#### Плюсы и минусы delta events

**Плюсы**:

- События будут меньше по размеру, в отличии от state событий, так как там не будет ничего лишнего;
- Если изменения частые – можно выиграть в трафике и количестве данных, которые храняться на стороне консьюмера;

**Минусы**:

- Исправление проблем со схемой событий может стать еще большей проблемой. Частный случай – решение проблемы GDPR и другие "удаления" данных могут быть проблемными;
- Придется следить за event ordering;
- Если для обработки события нужен полный агрегат (все данные агрегата) – придется хранить локальное состояние агрегата;

### Event granularity

Вторая концепция раскрывает идею state/delta событий, но в плоскости полезности и полноты события. Для этого вводятся понятия coarse и  fine событий.

{%
    include image.html
    url="/public/images/questions/2024-08-30-make-events-small/fine-vs-coarse-events.jpg"
    description="Пример двух одинаковых событий с добавлением товара в корзину. В coarse событии слишком много не понятно зачем относящихся данных, fine событие слишком специфичное и мелкое"
    altdescription="dbml: code and visualisation"
%}

#### Coarse событие

Такие события большие и общие (т.е. обо всем сразу), содержат дженерик нейминг и кучу данных не обязательных (и местами не нужных) для работы консьюмера.

Иногда встречаются ситуации, когда событие так себе называется и контекст того, что произошло, можно понять только через чтение данных. Из-за этого бизнес логика просачивается на сторону консьюмера.

#### Fine событие

Такие события слишком мелкие и специфичные. Чаще нормально называются, но слишком в них мало информации для работы бизнес логики

Считается, что такое событие не юзабельно без других событий, следовательно приходится их комбинировать и это может привести к проблемам, что потенциально может привести к проблемам с event ordering.

### Собираем концепции вместе

Если соединить две концепции, то появляется пространство выбора, в котором можно определить как оптимальный размер события, так то, на сколько общим (generic) событие будет в системе.

{%
    include image.html
    url="/public/images/questions/2024-08-30-make-events-small/fine-coarse-state-delta-matrix-event-size.jpg"
    description="Примерное описание того, какой размер события ожидать в каждом из мест «матрицы». Цветом показал ожидаемый размер события. Fine delta событие будет самым мелким, поэтому стикер зеленый"
    altdescription="dbml: code and visualisation"
%}

В таком ключе, вся работа над размером событий сводится к тому, что бы сначала сначала определяется какой вид события нужен: state или delta. После чего определяем проблему гранулярности события и решаем найденную проблему.

Благодаря этому можно выбирать размер события. Что приводит к тому, что каждое событие будет оптимально по размеру и контексту под заданные требования и ограничения. Благодаря чему можно отказаться от «моды»/советов на delta события без данных, просто потому что в компании Х используется такой подход по дефолту.

Но у такого подхода присутствует и минус: придется думать над каждым событием, что может привести к разногласиям в команде, либо же к проблемам, если разработчики не скиловые. Можно решить что хватит delta/fine события, а потом окажется, что не попали в требования. Из-за чего придется заниматься дорогой и сложной эволюцией схемы события.

## Событие корректное по размеру, но слишком большое для системы

К сожалению, использование концепции `state (fact) vs delta (action) events` и `event granularity` не спасает в 100% случаев от проблем с размером события. Возможна ситуация, когда необходим state event, который при этом должен быть coarse. Т.е. вообще никак не выбрать ничего другого. А размер события должен быть максимально небольшим ибо специфика брокера/нет денег на инфру/etc.

Чтобы решить эту проблему перечислю точечные подходы, которые разбиваются на две группы:

- уменьшаем payload сообщения с помощью паттернов \*;
- увеличиваем допустимые размеры сообщения в брокере;

\* Для некоторых вариантов придется подумать о консистентности данных в payload, ибо не все варианты работают со strong consistency.

### Уменьшение размера сообщений без потери гранулярности

#### Убрать лишние данные в ручную

Очевидное решение, пересекающее с концепциями из первой части ответа: берем событие, смотрим какие данные нужны в каждом консьюмере события, после чего, ковыряясь в payload, выкидываем лишние данные. Т.е. делаем событие больше fine чем coarse:

{%
    include image.html
    url="/public/images/questions/2024-08-30-make-events-small/less-coarse-event.jpg"
    description="Может оказаться, что событие надо сделать не таким coarse, следовательно, по «матрице» оно опустится чуть ниже"
    altdescription="dbml: code and visualisation"
%}

#### Event notification

Если получали смс «осторожно, будет шторм», а потом шли смотреть где шторм, когда и кого зацепит – значит знакомы с паттерном.

По сути, паттерн частный случай delta события. Идея такая: отправляем событие, что что-то произошло, но контекст просим получить с помощью синхронного вызова. Подход нужен в двух случаях: когда необходимо передать большое количество данных, либо когда нужно максимально консистеные данные получить в событии. В контексте ответа на вопрос интересен первый случай.

{%
    include image.html
    url="/public/images/questions/2024-08-30-make-events-small/event-notification-example.jpg"
    description="Пример реализации event notification паттерна. Сначала отправляется событие с ссылкой на ресурс. После этого, консьюмер, делает запрос за данными и получает контекст"
    altdescription="dbml: code and visualisation"
%}

Подобным образом можно передавать аттачменты в событиях: кидаем файл в s3, получаем ссылку, а после ссылку передаем в событии, благодаря чему можно не грузить гигабайты видео и картинок в брокер.

Из минусов подхода – появляется дополнительный каплинг за счет синхронной связи, что влияет на reliability, availability и другие характеристики.

#### Воспользоваться бинарной сериализацией

Если удалять из схемы payload нечего, а использовать синхронный вызов не позволяют характеристики, можно ужать само сообщение. Для этого берем бинарный серелизатор и упаковываем payload. По итогу получаем ужатую строку, которая меньше на 25-50% чем оригинальный payload (больше данных - больше ужимает).

Из минусов - без десериализации человек такую бинарную строку быстро не прочитает, в отличии от human-readable форматов (json, xml, etc). Еще из минусов – придется думать как консьюмер поймет какую схему использовать для десерелизации (либо 1 событие на топик/очередь, либо название события в headers кафки прокидывать).

Популярные серелизаторы: [protobuf](https://github.com/protocolbuffers/protobuf) (в grpc используется), [avro](https://github.com/apache/avro), [apache thrift](https://github.com/apache/thrift). В некоторых языках реализованы решения из коробки, [например в erlang](https://www.erlang.org/doc/apps/erts/erl_ext_dist.html) (использовать только тем, кто контрибьютил в пакет).

{%
    include image.html
    url="/public/images/questions/2024-08-30-make-events-small/avro-vs-protobuf-size-comparison.jpg"
    description="Разработчик решил проверить, что будет если [ужать датасет kaggle 2015 года от reddit](https://cristian-matei-toader.medium.com/compressing-a-year-of-reddit-with-apache-avro-and-google-protobuf-c9e40cf90444). Скриншот выше – итоговый результат, который мало говорит о том, что лучше, но показывающий как можно уменьшить размер события"
    altdescription="dbml: code and visualisation"
%}

#### Message chunking

Если описанные выше варианты не подошли, можно воспользоваться идеей передачи больших данных в синхронных вызовах: поделить сообщение на чанки меньшего размера и вместо одного жирного события получить N мелких.

Из минусов – проблемы с strong consistency для payload события, плюс проблемы упаковки чанков в событие на стороне консьюмера.

{%
    include image.html
    url="/public/images/questions/2024-08-30-make-events-small/message-chunking-example.jpg"
    description="Пример из вики apache pulsar. Идея в том, что событие разбивается на чанки (`M1-C1`, `M1-C2`), после чего консьюмер собирает из чанков исходное событие"
    altdescription="dbml: code and visualisation"
%}

#### Передавать часть данных в других событиях

На первый взгляд решение может показаться идентичным message chunking, но концепция чуть отличается. 

Идея в том, что можно разделить связи между элементами в плоскости [system function и system form](https://en.wikipedia.org/wiki/Form,_fit_and_function). Благодаря чему появится два вида связности: по данным (это form) и на уровне поведения (function). Это приводит к идее, что если присутствует событие, которое говорит о поведении, для обработки которого нужны данные, эти данные можно передать через system form связь.

Для определения system form можно воспользоваться [концептуальной data model](https://pepegramming.site/questions/data-model/), а для определения system function – любой моделью, описывающей поведение, например EventStorming.

### Тюнинг брокера

Сразу скажу – не эксперт в инфраструктуре, поэтому накину идей. Лучше идите к DevOps инженерам или админам (сам так делаю).

Как могу судить, тут два подхода: либо крутить конфиг брокера, либо использовать специфичные инструменты реализованные в брокере:

- Если возникла проблема, что событие не влезает в брокер, то можно накрутить конфиг [кафки](https://stackoverflow.com/questions/21020347/how-can-i-send-large-messages-with-kafka-over-15mb) или [кролика, но тут лимит в 128 мб](https://www.cloudamqp.com/blog/what-is-the-message-size-limit-in-rabbitmq.html). Для других брокеров думаю можно найти аналогичные настройки;
- Если используете кафку, советую посмотреть в сторону [message compression](https://www.confluent.io/blog/apache-kafka-message-compression/). Подход сработает для xml, json и прочего, что легко компрессируется и содержит дубли. По сути, аналог серелизации из списка выше;

Знаете еще варианты? Пишите в комментариях к тг посту, соберем список, а я дополню эту часть ответа.

## Выводы

Уменьшение объема payload события не тривиальная задача, которую в первую очередь лучше решать через `state (fact) vs delta (action) events` и `event granularity` концепции. Но даже так, возникают ситуации, когда приходится точечно исправлять ситуацию, с чем помогают как паттерны, так и прямой конфиг брокера (если возможен).

А чтобы собрать ответ в кучу, сделал decision flow диаграмму, которую сам использую, когда проектирую события, надеюсь поможет.

{%
    include image.html
    url="/public/images/questions/2024-08-30-make-events-small/event-size-decision-flow.jpg"
    description="Флоу выбора решения, который использую, если дело касается размера payload события"
    altdescription="dbml: code and visualisation"
%}

Хотя, в идеале, лучше жить в мире, в котором денег много, а инструменты не ограничивают в размере событий. 

## Ссылки

- [en]  [Статья, которая рассказывает о концепции event granularity с fine и coarse событиями](https://barryosull.com/blog/event-granularity-modelling-events-in-event-driven-applications/). При этом, автор объясняет почему появляются те или иные виды событий события;
- [en]  [Статья о state и delta событиях](https://developer.confluent.io/courses/event-design/fact-vs-delta-events/). Текста много, но и объясняется куча нюансов;

- [en]  [Сравнение avro и protobuf серелизаторов](https://www.funnel-labs.io/2022/08/26/data-serialization-apache-avro-vs-google-protobuf/) между собой;
- [4 глава DDIA](https://dataintensive.net) посвящена сериализации данных. Если не читали – рекомендую;
- [en]  [Статья, в которой автор вдохновился DDIA и решил ужать датасет реддита](https://cristian-matei-toader.medium.com/compressing-a-year-of-reddit-with-apache-avro-and-google-protobuf-c9e40cf90444), чтобы понять какой сериализатор лучше. Результат проверки найдете картинкой в ответе выше;

- [en]  Советы по работе с большими сообщениями, которые описаны в вики apache pulsar. [Message chunking – один из вариантов решения](https://github.com/apache/pulsar/wiki/PIP-37:-Large-message-size-handling-in-Pulsar#option-2-producer-publish-marker-message-after-publishing-all-chunked-messages);

- [ru] Подробнее о разделении коммуникаций на поведение и данные (form, function) можно [почитать в открытом уроке курса](https://f213.notion.site/dfa7f424ed8440d99a21c328cc8c5c65), по анализу систем, который сделал;

- [en] Автор дает [советы тем, кто использует aws инфраструктуру и хочет работать с большими событиями](https://jcdubs.medium.com/aws-large-payload-pattern-e3e4c57d402d). Примеры кода на js;
